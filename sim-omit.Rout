
R version 3.6.2 (2019-12-12) -- "Dark and Stormy Night"
Copyright (C) 2019 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> setwd("/home/herashi/MRT")
> 
> 
> library("foreach")
> library("doParallel")
Loading required package: iterators
Loading required package: parallel
> library("parallel")
> source("init.R")

Attaching package: ‘zoo’

The following objects are masked from ‘package:base’:

    as.Date, as.Date.numeric


Attaching package: ‘purrr’

The following objects are masked from ‘package:foreach’:

    accumulate, when

> source("rsnmm.R")
> source("group.R")
> 
> 
> 
> ## set number of Monte Carlo replicates
> 
> M <- 1000
> 
> ## set number of threads to use for parallel processing and the random seed
> ## (nb: these two values ensure that the results are replicable)
> cores <- 4
> seed <- 0
> 
> cl <- makeCluster(getOption("cl.cores", cores))
> clusterEvalQ(cl, source("init.R"))
[[1]]
[[1]]$value
[[1]]$value$value
function (n = 30, tmax = 30, M = 1000, y.formula = list(w = y ~ 
    I(a - pn) * (base + state), u = y ~ a * (base + state)), 
    y.names = c(w = "Weighted and centered", u = "GEE AR(1)"), 
    y.label = list(w = "I(a - pn)"), y.args = list(w = list(wn = "pn", 
        wd = "pd"), u = list(corstr = "ar1")), a.formula = list(pn = a ~ 
        lag1a, pd = a ~ lag1a + state), a.names = c(pn = "Last treatment", 
        pd = "Last treatment and current state"), lag = 0, verbose = TRUE, 
    group_ls, control, ...) 
{
    control <- if (missing(control)) 
        rsnmm.control(...)
    else control <- do.call("rsnmm.control", control)
    runin.fita <- control$lag
    runin.fity <- control$lag + lag
    y.coef <- mapply(which.terms, x = y.formula, label = y.label, 
        stripnames = TRUE, SIMPLIFY = FALSE)
    truth <- control[[paste0("beta", lag)]]
    truth <- truth[Reduce("intersect", lapply(y.coef, names))]
    y.coef <- lapply(y.coef, function(x) x[names(truth)])
    if (!is.null(a.formula)) {
        y.prob <- lapply(y.args, function(x) do.call("c", x[c("wn", 
            "wd")]))
        y.prob <- lapply(y.prob, function(x) x[x %in% names(a.formula)])
    }
    else y.prob <- lapply(y.formula, function(x) list())
    if (verbose) {
        cat("\nGenerative model attributes\n\n")
        print(control)
        cat("Analysis models\n\n")
        mapply(function(f, nm) write.table(cbind("  ", nm, ": y ~ ", 
            as.character(f)[3]), sep = "", row.names = FALSE, 
            col.names = FALSE, quote = FALSE, eol = "\n\n"), 
            f = y.formula, nm = y.names)
        cat("Treatment probability models\n\n")
        mapply(function(f, nm) write.table(cbind("  ", nm, ": a ~ ", 
            as.character(f)[3]), sep = "", row.names = FALSE, 
            col.names = FALSE, quote = FALSE, eol = "\n\n"), 
            f = a.formula, nm = a.names)
    }
    fitter <- function(formula, args, prob, coef, label, response = "y", 
        addvar = NULL) {
        if (response == "a") {
            args$family <- binomial()
            runin <- runin.fita
        }
        else runin <- runin.fity
        r <- which(d$time >= runin)
        l <- list(x = model.matrix(formula, data = d[r, ]), y = d[r, 
            response])
        if (is.null(args$wn) & is.null(args$wd)) 
            l$w <- rep(1, nrow(d))
        else {
            l$w <- ifelse(d[, "a"] == 1, d[, args$wn]/d[, args$wd], 
                (1 - d[, args$wn])/(1 - d[, args$wd]))
            args[c("wn", "wd")] <- NULL
        }
        l$w <- l$w * d$avail
        if (lag) 
            l$w <- delay(d$id, d$time, l$w, lag)
        l$w <- l$w[r]
        if (!is.null(args$corstr)) {
            fun <- "geese.glm"
            l$id <- d$id[r]
        }
        else if (!is.null(args$family)) 
            fun <- "glm.fit"
        else fun <- "lm.wfit"
        fit <- do.call(fun, c(l, args))
        if (!inherits(fit, "geeglm")) {
            fit <- glm2gee(fit, d$id[r])
            fit$terms <- terms(formula)
            fit$geese$X <- l$x
            fit$y <- l$y
        }
        if (!is.null(addvar)) {
            newvar <- paste0(c("", "lag1"), addvar)
            d[, newvar] <<- NA
            d[r, newvar[1]] <<- fit$fitted.values
            d[, newvar[2]] <<- delay(d$id, d$time, d[, newvar[1]])
        }
        else {
            fit$vcov <- vcov.geeglm(fit)
            est <- estimate(fit)[coef, 1:4, drop = FALSE]
            l <- if (length(prob)) 
                setNames(fita[prob], gsub("^w", "p", names(prob)))
            else NULL
            fit$vcov <- NULL
            fit$vcov <- do.call("vcov.geeglm", c(list(x = fit, 
                label = label), l))
            estc <- estimate(fit)[coef, 1:4, drop = FALSE]
            fit <- data.frame(moderator = names(coef), truth = truth, 
                est = est[, "Estimate"], se = est[, "SE"], lcl = est[, 
                  "95% LCL"], ucl = est[, "95% UCL"], sec = estc[, 
                  "SE"], lclc = estc[, "95% LCL"], uclc = estc[, 
                  "95% UCL"], row.names = NULL)
        }
        fit
    }
    fita <- list()
    out <- foreach(m = 1:M, .combine = "rbind") %dopar% {
        d <- rsnmm.R(n, tmax, group_ls, control = control)
        d$pn <- d$pd <- d$prob
        if (!is.null(a.formula)) 
            fita <- mapply(fitter, formula = a.formula, addvar = names(a.formula), 
                MoreArgs = list(args = list(), prob = list(), 
                  coef = list(), label = list(), response = "a"), 
                SIMPLIFY = FALSE)
        fity <- mapply(fitter, formula = y.formula, args = y.args, 
            prob = y.prob, coef = y.coef, label = y.label, SIMPLIFY = FALSE)
        fity <- mapply(function(nm, d) data.frame(iter = m, method = nm, 
            d, row.names = NULL), nm = y.names[names(fity)], 
            d = fity, SIMPLIFY = FALSE)
        out <- do.call("rbind", setNames(fity, NULL))
    }
    out <- data.frame(n, tmax, out)
    out$cp <- with(out, lcl <= truth & truth <= ucl)
    out$cpc <- with(out, lclc <= truth & truth <= uclc)
    out$rmse <- with(out, (est - truth)^2)
    out <- cbind(aggregate(cbind(est, se, sec, cp, cpc, rmse) ~ 
        method + moderator + truth + n + tmax, data = out, FUN = mean), 
        sd = aggregate(est ~ method + moderator + truth + n + 
            tmax, data = out, FUN = sd)$est, iter = aggregate(iter ~ 
            method + moderator + truth + n + tmax, data = out, 
            FUN = function(x) length(unique(x)))$iter)
    out$rmse <- sqrt(out$rmse)
    out
}

[[1]]$value$visible
[1] FALSE


[[1]]$visible
[1] FALSE


[[2]]
[[2]]$value
[[2]]$value$value
function (n = 30, tmax = 30, M = 1000, y.formula = list(w = y ~ 
    I(a - pn) * (base + state), u = y ~ a * (base + state)), 
    y.names = c(w = "Weighted and centered", u = "GEE AR(1)"), 
    y.label = list(w = "I(a - pn)"), y.args = list(w = list(wn = "pn", 
        wd = "pd"), u = list(corstr = "ar1")), a.formula = list(pn = a ~ 
        lag1a, pd = a ~ lag1a + state), a.names = c(pn = "Last treatment", 
        pd = "Last treatment and current state"), lag = 0, verbose = TRUE, 
    group_ls, control, ...) 
{
    control <- if (missing(control)) 
        rsnmm.control(...)
    else control <- do.call("rsnmm.control", control)
    runin.fita <- control$lag
    runin.fity <- control$lag + lag
    y.coef <- mapply(which.terms, x = y.formula, label = y.label, 
        stripnames = TRUE, SIMPLIFY = FALSE)
    truth <- control[[paste0("beta", lag)]]
    truth <- truth[Reduce("intersect", lapply(y.coef, names))]
    y.coef <- lapply(y.coef, function(x) x[names(truth)])
    if (!is.null(a.formula)) {
        y.prob <- lapply(y.args, function(x) do.call("c", x[c("wn", 
            "wd")]))
        y.prob <- lapply(y.prob, function(x) x[x %in% names(a.formula)])
    }
    else y.prob <- lapply(y.formula, function(x) list())
    if (verbose) {
        cat("\nGenerative model attributes\n\n")
        print(control)
        cat("Analysis models\n\n")
        mapply(function(f, nm) write.table(cbind("  ", nm, ": y ~ ", 
            as.character(f)[3]), sep = "", row.names = FALSE, 
            col.names = FALSE, quote = FALSE, eol = "\n\n"), 
            f = y.formula, nm = y.names)
        cat("Treatment probability models\n\n")
        mapply(function(f, nm) write.table(cbind("  ", nm, ": a ~ ", 
            as.character(f)[3]), sep = "", row.names = FALSE, 
            col.names = FALSE, quote = FALSE, eol = "\n\n"), 
            f = a.formula, nm = a.names)
    }
    fitter <- function(formula, args, prob, coef, label, response = "y", 
        addvar = NULL) {
        if (response == "a") {
            args$family <- binomial()
            runin <- runin.fita
        }
        else runin <- runin.fity
        r <- which(d$time >= runin)
        l <- list(x = model.matrix(formula, data = d[r, ]), y = d[r, 
            response])
        if (is.null(args$wn) & is.null(args$wd)) 
            l$w <- rep(1, nrow(d))
        else {
            l$w <- ifelse(d[, "a"] == 1, d[, args$wn]/d[, args$wd], 
                (1 - d[, args$wn])/(1 - d[, args$wd]))
            args[c("wn", "wd")] <- NULL
        }
        l$w <- l$w * d$avail
        if (lag) 
            l$w <- delay(d$id, d$time, l$w, lag)
        l$w <- l$w[r]
        if (!is.null(args$corstr)) {
            fun <- "geese.glm"
            l$id <- d$id[r]
        }
        else if (!is.null(args$family)) 
            fun <- "glm.fit"
        else fun <- "lm.wfit"
        fit <- do.call(fun, c(l, args))
        if (!inherits(fit, "geeglm")) {
            fit <- glm2gee(fit, d$id[r])
            fit$terms <- terms(formula)
            fit$geese$X <- l$x
            fit$y <- l$y
        }
        if (!is.null(addvar)) {
            newvar <- paste0(c("", "lag1"), addvar)
            d[, newvar] <<- NA
            d[r, newvar[1]] <<- fit$fitted.values
            d[, newvar[2]] <<- delay(d$id, d$time, d[, newvar[1]])
        }
        else {
            fit$vcov <- vcov.geeglm(fit)
            est <- estimate(fit)[coef, 1:4, drop = FALSE]
            l <- if (length(prob)) 
                setNames(fita[prob], gsub("^w", "p", names(prob)))
            else NULL
            fit$vcov <- NULL
            fit$vcov <- do.call("vcov.geeglm", c(list(x = fit, 
                label = label), l))
            estc <- estimate(fit)[coef, 1:4, drop = FALSE]
            fit <- data.frame(moderator = names(coef), truth = truth, 
                est = est[, "Estimate"], se = est[, "SE"], lcl = est[, 
                  "95% LCL"], ucl = est[, "95% UCL"], sec = estc[, 
                  "SE"], lclc = estc[, "95% LCL"], uclc = estc[, 
                  "95% UCL"], row.names = NULL)
        }
        fit
    }
    fita <- list()
    out <- foreach(m = 1:M, .combine = "rbind") %dopar% {
        d <- rsnmm.R(n, tmax, group_ls, control = control)
        d$pn <- d$pd <- d$prob
        if (!is.null(a.formula)) 
            fita <- mapply(fitter, formula = a.formula, addvar = names(a.formula), 
                MoreArgs = list(args = list(), prob = list(), 
                  coef = list(), label = list(), response = "a"), 
                SIMPLIFY = FALSE)
        fity <- mapply(fitter, formula = y.formula, args = y.args, 
            prob = y.prob, coef = y.coef, label = y.label, SIMPLIFY = FALSE)
        fity <- mapply(function(nm, d) data.frame(iter = m, method = nm, 
            d, row.names = NULL), nm = y.names[names(fity)], 
            d = fity, SIMPLIFY = FALSE)
        out <- do.call("rbind", setNames(fity, NULL))
    }
    out <- data.frame(n, tmax, out)
    out$cp <- with(out, lcl <= truth & truth <= ucl)
    out$cpc <- with(out, lclc <= truth & truth <= uclc)
    out$rmse <- with(out, (est - truth)^2)
    out <- cbind(aggregate(cbind(est, se, sec, cp, cpc, rmse) ~ 
        method + moderator + truth + n + tmax, data = out, FUN = mean), 
        sd = aggregate(est ~ method + moderator + truth + n + 
            tmax, data = out, FUN = sd)$est, iter = aggregate(iter ~ 
            method + moderator + truth + n + tmax, data = out, 
            FUN = function(x) length(unique(x)))$iter)
    out$rmse <- sqrt(out$rmse)
    out
}

[[2]]$value$visible
[1] FALSE


[[2]]$visible
[1] FALSE


[[3]]
[[3]]$value
[[3]]$value$value
function (n = 30, tmax = 30, M = 1000, y.formula = list(w = y ~ 
    I(a - pn) * (base + state), u = y ~ a * (base + state)), 
    y.names = c(w = "Weighted and centered", u = "GEE AR(1)"), 
    y.label = list(w = "I(a - pn)"), y.args = list(w = list(wn = "pn", 
        wd = "pd"), u = list(corstr = "ar1")), a.formula = list(pn = a ~ 
        lag1a, pd = a ~ lag1a + state), a.names = c(pn = "Last treatment", 
        pd = "Last treatment and current state"), lag = 0, verbose = TRUE, 
    group_ls, control, ...) 
{
    control <- if (missing(control)) 
        rsnmm.control(...)
    else control <- do.call("rsnmm.control", control)
    runin.fita <- control$lag
    runin.fity <- control$lag + lag
    y.coef <- mapply(which.terms, x = y.formula, label = y.label, 
        stripnames = TRUE, SIMPLIFY = FALSE)
    truth <- control[[paste0("beta", lag)]]
    truth <- truth[Reduce("intersect", lapply(y.coef, names))]
    y.coef <- lapply(y.coef, function(x) x[names(truth)])
    if (!is.null(a.formula)) {
        y.prob <- lapply(y.args, function(x) do.call("c", x[c("wn", 
            "wd")]))
        y.prob <- lapply(y.prob, function(x) x[x %in% names(a.formula)])
    }
    else y.prob <- lapply(y.formula, function(x) list())
    if (verbose) {
        cat("\nGenerative model attributes\n\n")
        print(control)
        cat("Analysis models\n\n")
        mapply(function(f, nm) write.table(cbind("  ", nm, ": y ~ ", 
            as.character(f)[3]), sep = "", row.names = FALSE, 
            col.names = FALSE, quote = FALSE, eol = "\n\n"), 
            f = y.formula, nm = y.names)
        cat("Treatment probability models\n\n")
        mapply(function(f, nm) write.table(cbind("  ", nm, ": a ~ ", 
            as.character(f)[3]), sep = "", row.names = FALSE, 
            col.names = FALSE, quote = FALSE, eol = "\n\n"), 
            f = a.formula, nm = a.names)
    }
    fitter <- function(formula, args, prob, coef, label, response = "y", 
        addvar = NULL) {
        if (response == "a") {
            args$family <- binomial()
            runin <- runin.fita
        }
        else runin <- runin.fity
        r <- which(d$time >= runin)
        l <- list(x = model.matrix(formula, data = d[r, ]), y = d[r, 
            response])
        if (is.null(args$wn) & is.null(args$wd)) 
            l$w <- rep(1, nrow(d))
        else {
            l$w <- ifelse(d[, "a"] == 1, d[, args$wn]/d[, args$wd], 
                (1 - d[, args$wn])/(1 - d[, args$wd]))
            args[c("wn", "wd")] <- NULL
        }
        l$w <- l$w * d$avail
        if (lag) 
            l$w <- delay(d$id, d$time, l$w, lag)
        l$w <- l$w[r]
        if (!is.null(args$corstr)) {
            fun <- "geese.glm"
            l$id <- d$id[r]
        }
        else if (!is.null(args$family)) 
            fun <- "glm.fit"
        else fun <- "lm.wfit"
        fit <- do.call(fun, c(l, args))
        if (!inherits(fit, "geeglm")) {
            fit <- glm2gee(fit, d$id[r])
            fit$terms <- terms(formula)
            fit$geese$X <- l$x
            fit$y <- l$y
        }
        if (!is.null(addvar)) {
            newvar <- paste0(c("", "lag1"), addvar)
            d[, newvar] <<- NA
            d[r, newvar[1]] <<- fit$fitted.values
            d[, newvar[2]] <<- delay(d$id, d$time, d[, newvar[1]])
        }
        else {
            fit$vcov <- vcov.geeglm(fit)
            est <- estimate(fit)[coef, 1:4, drop = FALSE]
            l <- if (length(prob)) 
                setNames(fita[prob], gsub("^w", "p", names(prob)))
            else NULL
            fit$vcov <- NULL
            fit$vcov <- do.call("vcov.geeglm", c(list(x = fit, 
                label = label), l))
            estc <- estimate(fit)[coef, 1:4, drop = FALSE]
            fit <- data.frame(moderator = names(coef), truth = truth, 
                est = est[, "Estimate"], se = est[, "SE"], lcl = est[, 
                  "95% LCL"], ucl = est[, "95% UCL"], sec = estc[, 
                  "SE"], lclc = estc[, "95% LCL"], uclc = estc[, 
                  "95% UCL"], row.names = NULL)
        }
        fit
    }
    fita <- list()
    out <- foreach(m = 1:M, .combine = "rbind") %dopar% {
        d <- rsnmm.R(n, tmax, group_ls, control = control)
        d$pn <- d$pd <- d$prob
        if (!is.null(a.formula)) 
            fita <- mapply(fitter, formula = a.formula, addvar = names(a.formula), 
                MoreArgs = list(args = list(), prob = list(), 
                  coef = list(), label = list(), response = "a"), 
                SIMPLIFY = FALSE)
        fity <- mapply(fitter, formula = y.formula, args = y.args, 
            prob = y.prob, coef = y.coef, label = y.label, SIMPLIFY = FALSE)
        fity <- mapply(function(nm, d) data.frame(iter = m, method = nm, 
            d, row.names = NULL), nm = y.names[names(fity)], 
            d = fity, SIMPLIFY = FALSE)
        out <- do.call("rbind", setNames(fity, NULL))
    }
    out <- data.frame(n, tmax, out)
    out$cp <- with(out, lcl <= truth & truth <= ucl)
    out$cpc <- with(out, lclc <= truth & truth <= uclc)
    out$rmse <- with(out, (est - truth)^2)
    out <- cbind(aggregate(cbind(est, se, sec, cp, cpc, rmse) ~ 
        method + moderator + truth + n + tmax, data = out, FUN = mean), 
        sd = aggregate(est ~ method + moderator + truth + n + 
            tmax, data = out, FUN = sd)$est, iter = aggregate(iter ~ 
            method + moderator + truth + n + tmax, data = out, 
            FUN = function(x) length(unique(x)))$iter)
    out$rmse <- sqrt(out$rmse)
    out
}

[[3]]$value$visible
[1] FALSE


[[3]]$visible
[1] FALSE


[[4]]
[[4]]$value
[[4]]$value$value
function (n = 30, tmax = 30, M = 1000, y.formula = list(w = y ~ 
    I(a - pn) * (base + state), u = y ~ a * (base + state)), 
    y.names = c(w = "Weighted and centered", u = "GEE AR(1)"), 
    y.label = list(w = "I(a - pn)"), y.args = list(w = list(wn = "pn", 
        wd = "pd"), u = list(corstr = "ar1")), a.formula = list(pn = a ~ 
        lag1a, pd = a ~ lag1a + state), a.names = c(pn = "Last treatment", 
        pd = "Last treatment and current state"), lag = 0, verbose = TRUE, 
    group_ls, control, ...) 
{
    control <- if (missing(control)) 
        rsnmm.control(...)
    else control <- do.call("rsnmm.control", control)
    runin.fita <- control$lag
    runin.fity <- control$lag + lag
    y.coef <- mapply(which.terms, x = y.formula, label = y.label, 
        stripnames = TRUE, SIMPLIFY = FALSE)
    truth <- control[[paste0("beta", lag)]]
    truth <- truth[Reduce("intersect", lapply(y.coef, names))]
    y.coef <- lapply(y.coef, function(x) x[names(truth)])
    if (!is.null(a.formula)) {
        y.prob <- lapply(y.args, function(x) do.call("c", x[c("wn", 
            "wd")]))
        y.prob <- lapply(y.prob, function(x) x[x %in% names(a.formula)])
    }
    else y.prob <- lapply(y.formula, function(x) list())
    if (verbose) {
        cat("\nGenerative model attributes\n\n")
        print(control)
        cat("Analysis models\n\n")
        mapply(function(f, nm) write.table(cbind("  ", nm, ": y ~ ", 
            as.character(f)[3]), sep = "", row.names = FALSE, 
            col.names = FALSE, quote = FALSE, eol = "\n\n"), 
            f = y.formula, nm = y.names)
        cat("Treatment probability models\n\n")
        mapply(function(f, nm) write.table(cbind("  ", nm, ": a ~ ", 
            as.character(f)[3]), sep = "", row.names = FALSE, 
            col.names = FALSE, quote = FALSE, eol = "\n\n"), 
            f = a.formula, nm = a.names)
    }
    fitter <- function(formula, args, prob, coef, label, response = "y", 
        addvar = NULL) {
        if (response == "a") {
            args$family <- binomial()
            runin <- runin.fita
        }
        else runin <- runin.fity
        r <- which(d$time >= runin)
        l <- list(x = model.matrix(formula, data = d[r, ]), y = d[r, 
            response])
        if (is.null(args$wn) & is.null(args$wd)) 
            l$w <- rep(1, nrow(d))
        else {
            l$w <- ifelse(d[, "a"] == 1, d[, args$wn]/d[, args$wd], 
                (1 - d[, args$wn])/(1 - d[, args$wd]))
            args[c("wn", "wd")] <- NULL
        }
        l$w <- l$w * d$avail
        if (lag) 
            l$w <- delay(d$id, d$time, l$w, lag)
        l$w <- l$w[r]
        if (!is.null(args$corstr)) {
            fun <- "geese.glm"
            l$id <- d$id[r]
        }
        else if (!is.null(args$family)) 
            fun <- "glm.fit"
        else fun <- "lm.wfit"
        fit <- do.call(fun, c(l, args))
        if (!inherits(fit, "geeglm")) {
            fit <- glm2gee(fit, d$id[r])
            fit$terms <- terms(formula)
            fit$geese$X <- l$x
            fit$y <- l$y
        }
        if (!is.null(addvar)) {
            newvar <- paste0(c("", "lag1"), addvar)
            d[, newvar] <<- NA
            d[r, newvar[1]] <<- fit$fitted.values
            d[, newvar[2]] <<- delay(d$id, d$time, d[, newvar[1]])
        }
        else {
            fit$vcov <- vcov.geeglm(fit)
            est <- estimate(fit)[coef, 1:4, drop = FALSE]
            l <- if (length(prob)) 
                setNames(fita[prob], gsub("^w", "p", names(prob)))
            else NULL
            fit$vcov <- NULL
            fit$vcov <- do.call("vcov.geeglm", c(list(x = fit, 
                label = label), l))
            estc <- estimate(fit)[coef, 1:4, drop = FALSE]
            fit <- data.frame(moderator = names(coef), truth = truth, 
                est = est[, "Estimate"], se = est[, "SE"], lcl = est[, 
                  "95% LCL"], ucl = est[, "95% UCL"], sec = estc[, 
                  "SE"], lclc = estc[, "95% LCL"], uclc = estc[, 
                  "95% UCL"], row.names = NULL)
        }
        fit
    }
    fita <- list()
    out <- foreach(m = 1:M, .combine = "rbind") %dopar% {
        d <- rsnmm.R(n, tmax, group_ls, control = control)
        d$pn <- d$pd <- d$prob
        if (!is.null(a.formula)) 
            fita <- mapply(fitter, formula = a.formula, addvar = names(a.formula), 
                MoreArgs = list(args = list(), prob = list(), 
                  coef = list(), label = list(), response = "a"), 
                SIMPLIFY = FALSE)
        fity <- mapply(fitter, formula = y.formula, args = y.args, 
            prob = y.prob, coef = y.coef, label = y.label, SIMPLIFY = FALSE)
        fity <- mapply(function(nm, d) data.frame(iter = m, method = nm, 
            d, row.names = NULL), nm = y.names[names(fity)], 
            d = fity, SIMPLIFY = FALSE)
        out <- do.call("rbind", setNames(fity, NULL))
    }
    out <- data.frame(n, tmax, out)
    out$cp <- with(out, lcl <= truth & truth <= ucl)
    out$cpc <- with(out, lclc <= truth & truth <= uclc)
    out$rmse <- with(out, (est - truth)^2)
    out <- cbind(aggregate(cbind(est, se, sec, cp, cpc, rmse) ~ 
        method + moderator + truth + n + tmax, data = out, FUN = mean), 
        sd = aggregate(est ~ method + moderator + truth + n + 
            tmax, data = out, FUN = sd)$est, iter = aggregate(iter ~ 
            method + moderator + truth + n + tmax, data = out, 
            FUN = function(x) length(unique(x)))$iter)
    out$rmse <- sqrt(out$rmse)
    out
}

[[4]]$value$visible
[1] FALSE


[[4]]$visible
[1] FALSE


> registerDoParallel(cl)
> 
> 
> sim.omit <- function() {
+   out <- NULL
+   ## low, medium and high degrees of moderation by state
+   for (b in c(0.2, 0.5, 0.8)) {
+     for (n in 100) {
+       group = group_all[[as.character(n)]]
+       for (tmax in c(30, 50)) {
+         clusterSetRNGStream(cl, seed)
+         out <-
+           rbind(out,
+                 cbind(level = paste("$\\beta_{11}^* = ", b, "$", sep = ""),
+                       sim(n, tmax, M, 
+                           ## regress response on state and proximal treatment,
+                           ## ignoring the underlying interaction between the two
+                           y.formula = list(w = y ~ state + I(a - pn),
+                                            u.ind = y ~ state + a,
+                                            u.ar1 = y ~ state + a,
+                                            u.exch = y ~ state + a),
+                           y.names = c(w = "Weighted and centered",
+                                       u.ind = "GEE independence",
+                                       u.ar1 = "GEE AR(1)",
+                                       u.exch = "GEE exchangeable"),
+                           ## term labels for proximal treatment
+                           y.label = list(w = "I(a - pn)",
+                                          u.ind = "a", u.ar1 = "a", u.exch = "a"),
+                           ## specify weights and working correlation structure
+                           y.args = list(w = list(wn = "pn", wd = "prob"),
+                                         u.ind = list(),
+                                         u.ar1 = list(corstr = "ar1"),
+                                         u.exch = list(corstr = "exch")),
+                           ## specify weight numerator model
+                           a.formula = list(pn = a ~ 1),
+                           a.names = c(pn = "Intercept-only"),
+                           ## use default generative model, but with the specified
+                           ## level of moderation by the time-varying state
+                           group_ls = group,
+                           beta0 = c(-0.2, 0, 0, b, 0))))
+       }
+     }
+   }
+   out
+ }
> 
> 
> 
> omit <- sim.omit()

Generative model attributes

$origin
[1] 1

$lag
[1] 3

$sd
[1] 1

$coralpha
[1] 0.7071068

$corstr
[1] "ar1"

$beta0
  one  tmod  base state lag1a 
 -0.2   0.0   0.0   0.2   0.0 

$beta1
      one  lag1tmod      base lag1state 
        0         0         0         0 

$eta
  one  base state lag1a lag1y 
  0.0   0.0   0.8  -0.8   0.0 

$mu
 one   ty base 
   0    0    0 

$theta0
avail state 
  0.0   0.8 

$theta1
lag1avail lag1state 
        0         0 

$coef.avail
   one tavail  lag1a  lag1y 
   100      0      0      0 

$coef.state
      one    tstate      base lag1state     lag1a 
        0         0         0         0         0 

$tfun
$tfun$ty
function (tcur, tmax) 
rep(0, length(tcur))
<environment: 0xc4bf9e0>

$tfun$tmod
function (tcur, tmax) 
rep(0, length(tcur))
<environment: 0xc4bf9e0>

$tfun$tavail
function (tcur, tmax) 
rep(0, length(tcur))
<environment: 0xc4bf9e0>

$tfun$tstate
function (tcur, tmax) 
rep(0, length(tcur))
<environment: 0xc4bf9e0>


Analysis models

  Weighted and centered: y ~ state + I(a - pn)

  GEE independence: y ~ state + a

  GEE AR(1): y ~ state + a

  GEE exchangeable: y ~ state + a

Treatment probability models

  Intercept-only: a ~ 1


Generative model attributes

$origin
[1] 1

$lag
[1] 3

$sd
[1] 1

$coralpha
[1] 0.7071068

$corstr
[1] "ar1"

$beta0
  one  tmod  base state lag1a 
 -0.2   0.0   0.0   0.2   0.0 

$beta1
      one  lag1tmod      base lag1state 
        0         0         0         0 

$eta
  one  base state lag1a lag1y 
  0.0   0.0   0.8  -0.8   0.0 

$mu
 one   ty base 
   0    0    0 

$theta0
avail state 
  0.0   0.8 

$theta1
lag1avail lag1state 
        0         0 

$coef.avail
   one tavail  lag1a  lag1y 
   100      0      0      0 

$coef.state
      one    tstate      base lag1state     lag1a 
        0         0         0         0         0 

$tfun
$tfun$ty
function (tcur, tmax) 
rep(0, length(tcur))
<environment: 0x96b3140>

$tfun$tmod
function (tcur, tmax) 
rep(0, length(tcur))
<environment: 0x96b3140>

$tfun$tavail
function (tcur, tmax) 
rep(0, length(tcur))
<environment: 0x96b3140>

$tfun$tstate
function (tcur, tmax) 
rep(0, length(tcur))
<environment: 0x96b3140>


Analysis models

  Weighted and centered: y ~ state + I(a - pn)

  GEE independence: y ~ state + a

  GEE AR(1): y ~ state + a

  GEE exchangeable: y ~ state + a

Treatment probability models

  Intercept-only: a ~ 1


Generative model attributes

$origin
[1] 1

$lag
[1] 3

$sd
[1] 1

$coralpha
[1] 0.7071068

$corstr
[1] "ar1"

$beta0
  one  tmod  base state lag1a 
 -0.2   0.0   0.0   0.5   0.0 

$beta1
      one  lag1tmod      base lag1state 
        0         0         0         0 

$eta
  one  base state lag1a lag1y 
  0.0   0.0   0.8  -0.8   0.0 

$mu
 one   ty base 
   0    0    0 

$theta0
avail state 
  0.0   0.8 

$theta1
lag1avail lag1state 
        0         0 

$coef.avail
   one tavail  lag1a  lag1y 
   100      0      0      0 

$coef.state
      one    tstate      base lag1state     lag1a 
        0         0         0         0         0 

$tfun
$tfun$ty
function (tcur, tmax) 
rep(0, length(tcur))
<environment: 0xe288610>

$tfun$tmod
function (tcur, tmax) 
rep(0, length(tcur))
<environment: 0xe288610>

$tfun$tavail
function (tcur, tmax) 
rep(0, length(tcur))
<environment: 0xe288610>

$tfun$tstate
function (tcur, tmax) 
rep(0, length(tcur))
<environment: 0xe288610>


Analysis models

  Weighted and centered: y ~ state + I(a - pn)

  GEE independence: y ~ state + a

  GEE AR(1): y ~ state + a

  GEE exchangeable: y ~ state + a

Treatment probability models

  Intercept-only: a ~ 1


Generative model attributes

$origin
[1] 1

$lag
[1] 3

$sd
[1] 1

$coralpha
[1] 0.7071068

$corstr
[1] "ar1"

$beta0
  one  tmod  base state lag1a 
 -0.2   0.0   0.0   0.5   0.0 

$beta1
      one  lag1tmod      base lag1state 
        0         0         0         0 

$eta
  one  base state lag1a lag1y 
  0.0   0.0   0.8  -0.8   0.0 

$mu
 one   ty base 
   0    0    0 

$theta0
avail state 
  0.0   0.8 

$theta1
lag1avail lag1state 
        0         0 

$coef.avail
   one tavail  lag1a  lag1y 
   100      0      0      0 

$coef.state
      one    tstate      base lag1state     lag1a 
        0         0         0         0         0 

$tfun
$tfun$ty
function (tcur, tmax) 
rep(0, length(tcur))
<environment: 0x82ce9e8>

$tfun$tmod
function (tcur, tmax) 
rep(0, length(tcur))
<environment: 0x82ce9e8>

$tfun$tavail
function (tcur, tmax) 
rep(0, length(tcur))
<environment: 0x82ce9e8>

$tfun$tstate
function (tcur, tmax) 
rep(0, length(tcur))
<environment: 0x82ce9e8>


Analysis models

  Weighted and centered: y ~ state + I(a - pn)

  GEE independence: y ~ state + a

  GEE AR(1): y ~ state + a

  GEE exchangeable: y ~ state + a

Treatment probability models

  Intercept-only: a ~ 1


Generative model attributes

$origin
[1] 1

$lag
[1] 3

$sd
[1] 1

$coralpha
[1] 0.7071068

$corstr
[1] "ar1"

$beta0
  one  tmod  base state lag1a 
 -0.2   0.0   0.0   0.8   0.0 

$beta1
      one  lag1tmod      base lag1state 
        0         0         0         0 

$eta
  one  base state lag1a lag1y 
  0.0   0.0   0.8  -0.8   0.0 

$mu
 one   ty base 
   0    0    0 

$theta0
avail state 
  0.0   0.8 

$theta1
lag1avail lag1state 
        0         0 

$coef.avail
   one tavail  lag1a  lag1y 
   100      0      0      0 

$coef.state
      one    tstate      base lag1state     lag1a 
        0         0         0         0         0 

$tfun
$tfun$ty
function (tcur, tmax) 
rep(0, length(tcur))
<environment: 0xee09428>

$tfun$tmod
function (tcur, tmax) 
rep(0, length(tcur))
<environment: 0xee09428>

$tfun$tavail
function (tcur, tmax) 
rep(0, length(tcur))
<environment: 0xee09428>

$tfun$tstate
function (tcur, tmax) 
rep(0, length(tcur))
<environment: 0xee09428>


Analysis models

  Weighted and centered: y ~ state + I(a - pn)

  GEE independence: y ~ state + a

  GEE AR(1): y ~ state + a

  GEE exchangeable: y ~ state + a

Treatment probability models

  Intercept-only: a ~ 1


Generative model attributes

$origin
[1] 1

$lag
[1] 3

$sd
[1] 1

$coralpha
[1] 0.7071068

$corstr
[1] "ar1"

$beta0
  one  tmod  base state lag1a 
 -0.2   0.0   0.0   0.8   0.0 

$beta1
      one  lag1tmod      base lag1state 
        0         0         0         0 

$eta
  one  base state lag1a lag1y 
  0.0   0.0   0.8  -0.8   0.0 

$mu
 one   ty base 
   0    0    0 

$theta0
avail state 
  0.0   0.8 

$theta1
lag1avail lag1state 
        0         0 

$coef.avail
   one tavail  lag1a  lag1y 
   100      0      0      0 

$coef.state
      one    tstate      base lag1state     lag1a 
        0         0         0         0         0 

$tfun
$tfun$ty
function (tcur, tmax) 
rep(0, length(tcur))
<environment: 0x8d5aee8>

$tfun$tmod
function (tcur, tmax) 
rep(0, length(tcur))
<environment: 0x8d5aee8>

$tfun$tavail
function (tcur, tmax) 
rep(0, length(tcur))
<environment: 0x8d5aee8>

$tfun$tstate
function (tcur, tmax) 
rep(0, length(tcur))
<environment: 0x8d5aee8>


Analysis models

  Weighted and centered: y ~ state + I(a - pn)

  GEE independence: y ~ state + a

  GEE AR(1): y ~ state + a

  GEE exchangeable: y ~ state + a

Treatment probability models

  Intercept-only: a ~ 1

Error in { : 
  task 402 failed - "system is computationally singular: reciprocal condition number = 8.8327e-138"
Calls: sim.omit -> rbind -> cbind -> sim -> %dopar% -> <Anonymous>
Execution halted
